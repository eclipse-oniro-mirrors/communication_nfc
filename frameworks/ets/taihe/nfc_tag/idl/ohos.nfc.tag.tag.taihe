/*
 * Copyright (c) 2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@!namespace("@ohos.nfc.tag", "tag")

@!sts_inject_into_module("import Want from '@ohos.app.ability.Want';")
@!sts_inject_into_module("import {ElementName} from 'bundleManager.ElementName';")
@!sts_inject_into_module("import type {PacMap} from 'ability.dataAbilityHelper';")
@!sts_inject_into_module("import rpc from '@ohos.rpc';")
@!sts_inject_into_module("import {BusinessError} from '@ohos.base';")

@!sts_inject("""
static { loadLibrary("nfc_fwk_taihe_tag.z"); }
""")

@!sts_inject("const NFC_A: int = 1")
@!sts_inject("const NFC_B: int = 2")
@!sts_inject("const ISO_DEP: int = 3")
@!sts_inject("const NFC_F: int = 4")
@!sts_inject("const NFC_V: int = 5")
@!sts_inject("const NDEF: int = 6")
@!sts_inject("const NDEF_FORMATABLE: int = 7")
@!sts_inject("const MIFARE_CLASSIC: int = 8")
@!sts_inject("const MIFARE_ULTRALIGHT: int = 9")
@!sts_inject("const NFC_BARCODE: int = 10")

from nfctech use NfcATag, NfcBTag, NfcFTag, NfcVTag, IsoDepTag, NdefTag, MifareClassicTag, MifareUltralightTag, NdefFormatableTag, BarcodeTag;

enum NfcForumType: i32 {
  NFC_FORUM_TYPE_1 = 1,
  NFC_FORUM_TYPE_2 = 2,
  NFC_FORUM_TYPE_3 = 3,
  NFC_FORUM_TYPE_4 = 4,
  MIFARE_CLASSIC = 101
}

enum TnfType: i32 {
  TNF_EMPTY = 0x0,
  TNF_WELL_KNOWN = 0x1,
  TNF_MEDIA = 0x2,
  TNF_ABSOLUTE_URI = 0x3,
  TNF_EXT_APP = 0x4,
  TNF_UNKNOWN = 0x5,
  TNF_UNCHANGED = 0x6
}

enum MifareClassicType: i32 {
  TYPE_UNKNOWN = 0,
  TYPE_CLASSIC = 1,
  TYPE_PLUS = 2,
  TYPE_PRO = 3
}

enum MifareClassicSize: i32 {
  MC_SIZE_MINI = 320,
  MC_SIZE_1K = 1024,
  MC_SIZE_2K = 2048,
  MC_SIZE_4K = 4096
}

enum MifareUltralightType: i32 {
  TYPE_UNKNOWN = 0,
  TYPE_ULTRALIGHT = 1,
  TYPE_ULTRALIGHT_C = 2
}

struct TagInfo {
  uid: Array<i32>;
  technology: Array<i32>;
  extrasData: Array<@sts_type("PacMap") Opaque>;
  remoteTagService: @sts_type("rpc.RemoteObject") Opaque;
  tagRfDiscId: i32;
}

struct NdefRecord {
  tnf: i32;
  rtdType: Array<i32>;
  id: Array<i32>;
  payload: Array<i32>;
}

function getNfcA(tagInfo: TagInfo): NfcATag;
function getNfcB(tagInfo: TagInfo): NfcBTag;
function getNfcF(tagInfo: TagInfo): NfcFTag;
function getNfcV(tagInfo: TagInfo): NfcVTag;
function getIsoDep(tagInfo: TagInfo): IsoDepTag;
function getNdef(tagInfo: TagInfo): NdefTag;
function getMifareClassic(tagInfo: TagInfo): MifareClassicTag;
function getMifareUltralight(tagInfo: TagInfo): MifareUltralightTag;
function getNdefFormatable(tagInfo: TagInfo): NdefFormatableTag;
function getBarcodeTag(tagInfo: TagInfo): BarcodeTag;

function getTagInfo(want: @sts_type("Want") Opaque): TagInfo;

function registerForegroundDispatch(elementName: @sts_type("ElementName") Opaque, discTech: Array<u32>,
  callback: (err: @sts_type("BusinessError<void>") Opaque, tagInfo: TagInfo) => void): void;
function unregisterForegroundDispatch(elementName: @sts_type("ElementName") Opaque): void;

function onReaderMode(elementName: @sts_type("ElementName") Opaque, discTech: Array<u32>,
  callback: (err: @sts_type("BusinessError<void>") Opaque, tagInfo: TagInfo) => void): void;
function offReaderMode(elementName: @sts_type("ElementName") Opaque,
  callback: Optional<(err: @sts_type("BusinessError<void>") Opaque, tagInfo: TagInfo) => void>): void;
